# TIL Template
날짜: 2025-02-04

<br/>

## 스크럼
**학습 목표:** KTB 강의 수강 후 개념 정리

<br/>
<br/>

## 새로 배운 내용
````
- 프로세스
- 스레드
- 자바 스레드
- 동시성 문제와 동기화 처리
````

<br/>

### 프로세스
#### 정의
- OS에서 자원을 할당받아 연속적으로 실행 중인 컴퓨터 프로그램
- 각 프로세스마다 독립된 메모리 공간을 가지며 독립적으로 작용

#### 문제 상황
- 메모리 공간의 독립성 문제: 독립된 메모리 공간이 동일한 데이터를 다루어야 하는 경우 동기화 및 통신 로직 필요
- 메모리 누수: 페이징된 풀 또는 비페이지 풀에서 메모리 할당 후 해제하지 않을 경우 발생

#### 메모리 영역
- **Code:** 프로그램의 실행 코드나 명령어들을 기계어 형태로 저장
    - CPU가 명령어를 순차적으로 읽어서 처리한다.
- **Data:** 코드 내 전역 변수와 정적 변수 저장, 프로그램 실행시 할당 → 종료시 소멸
- **Stack:** 함수 안 지역변수, 매개변수, 리턴값 저장, 함수 호출시 할당 → 종료시 소멸
- **Heap:** 동적으로 할당되는 데이터 저장(사용자의 입력 등)

#### 동작 방식
1. **로딩:** 프로그램 실행을 요청 → OS가 프로그램의 코드와 데이터를 메모리에 로드
2. **실행:** CPU가 프로그램의 명령어를 순차적으로 실행하여 작업 진행
3. **대기:** 프로그램 실행 중 외부 이벤트 발생 → 해당 이벤트가 완료될 때까지 대기 상태
4. **종료:** 더 이상 실행할 명령어가 없을시 → 메모리 해제 → 프로세스 종료

<br/>
<br/>

### 스레드
#### 정의
- 프로세스 내 자원과 메모리를 공유하며 병렬적으로 실행되는 흐름의 단위
- 프로세스의 Code, Data, Heap 공유
- 고유한 Stack, PC 레지스터 값 소유

**장점:** 자원 사용 효율성, 통신 용이성, 빠른 처리 속도
**단점:** 자원 공유 복잡성, 안정성 문제, 스레드 오버헤드

#### 문제 상황
- 동시성 문제: 두 스레드가 공유 자원에 대해 작업을 동시에 처리하려는 경우, 적절한 동기화 없이 접근한다면 두 스레드 간 결과값의 차이로 경쟁 상태(race condition) 발생 가능
    - 동시성 관리: 작업들을 동시에 실행할 때 발생할 수 있는 충돌 방지, 자원의 효율적 활용
    - 동시성(concurrency): 여러 작업이 내부적으로 빠른 속도로 번갈아가며 실행 → 동시에 실행되는 것처럼 보인다. (싱글 코어 - 멀티 스레드)
    - 병렬성(parallelism): 여러 작업이 실제로 동시에 실행 (멀티 코어 - 멀티 스레드)
- 메모리 누수

#### 동작 방식
프로세스 내에서 여러 스레드를 생성하여 병렬적으로 작업 수행
1. **동작:** 프로세스 실행 중 추가적인 스레드 생성
    - OS가 스레드를 동적으로 생성한다.
    - 각 스레드는 고유한 실행 흐름을 가진다.
2. **실행:** 각 스레드가 독립적인 실행 흐름으로 작업 처리
    - 프로세스의 자원 공유
    - CPU 스케줄링 → 병렬적 실행
3. **대기:** 스레드가 동기화/외부 이벤트가 완료될 때까지 기다리는 상태
    - 스레드 간 동기화: 같은 데이터를 볼 수 있도록 하는 것
4. **종료:** 스레드의 작업 완료 후 자원 반환
    - OS가 스레드가 점유한 메모리를 해제
    - 프로세스 내 다른 스레드에 영향 X

<br/>
<br/>

### 자바 스레드
동시 실행 흐름을 생성하고 제어하는 클래스
- **동시성:** 여러 작업 동시에 진행 가능 → 프로그램 성능 향상
- **응답성:** 사용자 입력에 더 빠르게 반응
    - 메인 스레드: 사용자 상호작용에 집중
    - 그외 스레드: 백그라운드 작업 처리
- **자원공유:** 여러 작업들이 메모리의 자원 공유 → 효율적인 작업 진행
    - 데이터 공유 과정 중 문제 → Syncronized를 통해 데이터 무결성 보장

#### 생성 및 실행
1. `Runnable` 인터페이스
````
class MyRunnable implements Runnable {
	public void run() {
		// 기능 작성
	}
}

MyRunnable myRunnable = new MyRunnable();
Thread thread = new Thread(myRunnable);
thread.start()
````
2. `Thread` 클래스
````
class MyThread extends Thread {
	public void run() {
		// 기능 작성
	}
}

MyThread thread = new MyThread();
thread.start();
````

#### 실행 순서
실행 순서를 보장하지 않는다.
- **동기(synchronous):** 직렬적 작동, 이전 작업이 종료된 후에 다음 작업 수행
- **비동기(asynchronous):** 병렬적 작동, 이전 작업 종료를 기다리지 않고 다음 작업 실행

<br/>
<br/>

### 동시성 문제와 동기화 처리
#### 동시성 문제
두 스레드가 공유 자원에 대해 작업을 동시에 처리하려는 경우, 두 스레드 간 결과값 차이로 경쟁 상태 발생

#### 동기화 처리
한 스레드가 진행 중인 작업을 다른 스레드가 간섭하지 못하도록 막는다.
- `synchronized` 키워드
````
public synchronized void function () {
	// 임계 영역
}
````
- `volatile` 키워드
````
public class SharedObject {
	public volatile int counter = 0;
}
````
- `Atomic` 클래스
````
AtomicLong atomicLong = new AtomicLong();
atomicLong.set(5L);

AtomicInteger atomicInteger = new AtomicInteger();
atomicInteger.set(5);

get() // 메모리에서 값을 가져온다.
set() // 메모리에 값을 저장한다.
````

<br/>
<br/>

## 오늘의 회고
- 원래부터 OS에 대해 다시 공부하고 싶은 마음이 있었는데 이번에 기회가 생겨 만족스럽다.
- 강의 시간 내에 모든 범위를 꼼꼼하게 다룰 수는 없을 테니 강의 내용으로 전체 흐름과 개념을 잡고, 따로 교재로 깊이 있게 공부해 봐야겠다.
- 추가로 실습에서 동기/비동기와 관련 없이 자꾸 스레드의 동작이 제대로 수행되지 않는 문제가 생겨서 여러 시도를 해본 결과, 스레드 `start()` 이후에 `join()`으로 스레드 작업 수행을 보장해야 결과가 제대로 출력된다는 걸 배웠다.

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->