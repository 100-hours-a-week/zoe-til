# TIL Template
날짜: 2025-02-14

<br/>

## 스크럼
**학습 목표:**
- 딥다이브 작성
- 3주차 과제 시작


<br/>
<br/>

## 새로 배운 내용
````
- Stateful, Stateless
- 브라우저의 동작 방식
- HTTP 메소드
- Web Server, WAS
- 정적 웹 페이지와 동적 웹 페이지
- JWT 토큰 탈취 해결법

````

<br/>

### 1. Stateful, Stateless
#### Stateful (상태 유지)
서버가 브라우저의 쿠키나 세션 메모리를 통해 클라이언트의 상태를 보존하며, 서버의 응답이 세션에 의존적이다.

**문제점**<br/>
1. 서버 장애가 발생하면 세션이 손실될 수 있다.
2. 클라이언트 수가 많아지면 서버의 부하가 높아지고 용량에 한계가 생긴다.
    ⇒ 클라이언트 상태 데이터를 캐시 서버(Redis)에 저장하여 사용

<br/>

#### Stateless (무상태)
서버가 클라이언트의 상태를 보존하지 않으며, 서버의 응답이 세션 상태와 독립적이다.
⇒ 클라이언트가 통신에 필요한 모든 상태 정보들을 가지고 있다가 서버와 통신할 때 포함하여 전달한다.

**장점**<br/>
1. 상태 유지에 대한 부하가 줄어든다.
2. 대량의 트래픽 발생 시 서버 확장을 통해 대처를 수월하게 할 수 있다.

**문제점**<br/>
1. 클라이언트 요청에 상대적으로 더 많은 데이터가 소모된다.
<br/>
**⇒ JWT 토큰:** stateless 상태를 유지하면서 로그인 상태는 stateful하게 유지하는 기술

<br/>

#### **사용자 상태 유지 방법**
**쿠키(Cookie): 클라이언트의 웹 브라우저에 저장, 서버는 쿠키를 통해 사용자의 상태 확인**<br/>
1. 서버에서 쿠키 생성: `Set-Cookie` 헤더를 통해 쿠키 생성 지시(`이름-값`)
2. 클라이언트에서 쿠키 저장: 로컬 저장소에 저장 후 요청 헤더에 포함
3. 서버에서 쿠키 확인

**세션(Session): 서버 측에 저장, 클라이언트는 서버에 접근할 때 세션 ID만 전송**<br/>
1. 클라이언트가 서버에 요청
2. 서버에서 세션 ID 생성: `Set-Cookie` 헤더를 통해 클라이언트의 쿠키에 저장
3. 서버에서 세션 관리: 세션 ID를 통해 세션 정보 확인
    - 서버 메모리, DB, 인메모리 데이터 저장소(Redis)
4. 세션 종료: 로그아웃, 기간 만료

**JWT(JSON Web Token): 인증에 필요한 정보를 암호화시킨 토큰을 전달**<br/>
1. 클라이언트의 로그인 요청
2. 서버가 사용자 확인 후 비밀키를 사용하여 Access Token(+ Refresh Token) 발급
3. 클라이언트에 토큰 저장 → 클라이언트의 데이터 요청시 헤더에 토큰 포함
4. 서버가 비밀키를 사용하여 Access Token 검증 후 응답

<br/>
<br/>

### 2. 브라우저의 동작 방식
#### 브라우저 구조
- **사용자 인터페이스(UI):** 주소창, 북마크 등 페이지 외 모든 UI 요소
- **브라우저 엔진:** UI-렌더링 엔진 사이의 중개자
- **렌더링 엔진:** HTML, CSS 파싱하여 화면에 렌더링
- **네트워크 레이어:** 서버와의 통신
- **JS 인터프리터:** JS 코드 해석 및 실행
- **UI 백엔드:** 운영체제별 UI 처리
- **데이터 저장소:** 쿠키, 로컬 저장소 등 로컬에 데이터 저장

<br/>

#### 렌더링 엔진의 동작 방식
1. **DOM 트리 생성**
    - **HTML 파싱**
        1. Byte의 데이터를 Character로 변환
        2. HTML 문서를 토큰으로 분할
        3. 토큰을 바탕으로 Node Tree 구축
            - Node: 문서의 각 요소
        4. Node Tree → DOM 트리로 변환
            - DOM(Document Object Model): 문서의 계층적 구조
2. **스타일 규칙 생성**
    - **CSS 파싱**
        1. Byte 데이터를 Character로 변환
        2. CSS 문서를 여러 개의 토큰으로 분할
        3. 토큰을 바탕으로 Node Tree 구축
        4. Node Tree → CSSOM 트리로 변환
            - CSSOM 트리: 스타일 규칙의 계층적 구조
3. **렌더 트리(Render Tree) 구축**<br/>
    DOM 트리 + CSSOM 트리 = Render Tree: 화면에 표시될 요소 결정
    
4. **레이아웃(Layout) 또는 리플로우(Reflow)**<br/>
    Render Tree → Layout Tree: 각 요소의 레이아웃(위치와 크기) 계산
    
5. **페인트(Paint) 또는 리페인트(Repaint)**<br/>
    레이아웃 단계에서 계산된 정보를 실제 픽셀로 변환하여 각 요소를 화면에 그린다.
    - 페인트 단계 시작 → 픽셀로 변환 → 컴포지팅

<br/>

#### JavaScript의 동작 과정

1. **HTML 파싱:** `<script>` 태그를 만나면 HTML 파싱을 멈추고 해당 스크립트를 JS 엔진에 전달한다.
2. **DOM과의 상호작용**
    1. JS 코드를 파싱 및 실행한다.
    2. DOM 조작 / 스타일 변경 → DOM 트리 / CSSOM 트리에 즉각 반영
3. **렌더링 엔진의 반응:** 레이아웃 (Reflow →) Repaint → Compositing
4. HTML 파싱을 재개한다.

<br/>
<br/>

### 3. HTTP 메소드
**리소스와 행위를 분리**
- URI는 리소스만 식별한다.
- HTTP 메소드를 통해 행위를 구분한다.
- HTTP Message Payload를 통해 행위의 내용을 전달한다.

<br/>

#### HTTP 주요 메소드
- **GET:** 리소스 조회        
- **POST:** 요청 데이터 처리, 신규 리소스 등록
- **PUT:** 리소스 대체(전체 변경) 또는 생성
- **PATCH:** 리소스 일부 변경
- **DELETE:** 리소스 삭제

<br/>

#### HTTP 메소드의 속성
안전(Safe): 리소스를 변경하지 않는가
-  GET

멱등(Idempotent): 여러 번 호출해도 결과가 동일한가
- GET, PUT, DELETE

캐시가능(Cacheable): 응답 리소스를 캐싱 가능한가
- GET, (POST, PATCH)

<br/>

**멱등 메소드:** **$f(f(x)) = f(x)$**<br/>
외부 요인으로 인한 리소스 변경을 고려하지 않고, 내가 호출하는 것에 한정한다.

**활용 방법:** 자동 복구 매커니즘<br/>
서버가 TIMEOUT 등으로 정상 응답을 하지 못했을 경우, 클라이언트에서 같은 요청이 가능한지 판단하는 근거
- Socket.IO를 통해 소켓 통신: 접속 실패시 재접속 시도 O
- webRTC에서 두 클라이언트 간 SDP 관계 수립 후 영상 송수신: 전송 실패시 재협상 시도

<br/>
<br/>

### 4. Web Server, WAS

#### Web Server
**개념**
- 하드웨어: Web 서버가 설치되어 있는 컴퓨터
- 소프트웨어: 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 콘텐츠(HTML, CSS, 이미지 파일 등)를 제공하는 컴퓨터 프로그램

**기능:** HTTP 프로토콜을 기반으로 클라이언트의 요청을 서비스한다.
1. 정적인 콘텐츠 제공: WAS를 거치지 않고 바로 자원을 제공한다.
2. 동적인 콘텐츠 제공: 클라이언트(웹 브라우저)의 요청을 WAS에 보내고 응답 결과를 클라이언트에게 전달한다.

⇒ 정적 콘텐츠만 처리하도록 WAS와 기능을 분배 → 서버 부하 감소

<br/>

#### WAS
*Web Application Server, Web Container, Servlet Container*<br/>
DB 조회나 다양한 로직 처리를 요구하는 동적인 콘텐츠를 제공하는 애플리케이션 서버이자 미들웨어(소프트웨어 엔진)
- ex. Tomcat

**기능**
1. 프로그램 실행 환경과 DB 접속 기능을 제공한다.
2. 여러 개의 트랜잭션을 관리한다.
3. 업무를 처리하는 비즈니스 로직을 수행한다.

⇒ 요청을 받고 실시간으로 적절한 동적 콘텐츠 제공 → 자원의 효율적 사용

#### 기능 분리의 장점
1. 서버 부하 방지
2. 물리적으로 분리하여 보안 강화
3. 여러 대의 WAS 연결
4. 여러 웹 애플리케이션 서비스 사용

⇒ 자원 이용의 효율성, 장애 극복, 배포 및 유지보수의 편의성

<br/>
<br/>

### 5. 정적 웹 페이지, 동적 웹 페이지

#### 정적 웹 페이지
*Static Web Page*<br/>
웹 서버에 이미 저장된 파일(HTML 파일, 이미지, JavaScript 파일 등)을 클라이언트에게 그대로 전송하는 웹 페이지
- 서버에 저장된 데이터가 변경되지 않는 한 고정된 결과의 웹 페이지 렌더링

#### 동적 웹 페이지
*Dynamic Web Page*<br/>
API를 통한 사용자의 요청에 따라 서버가 동적으로 페이지를 구성하는 웹 페이지
- 조건(상황, 시간, 요청 등)에 따라 다른 결과의 웹 페이지 렌더링

**종류**
- SSR (Server Side Rendering)
- CSR (Client SIde Rendering)
- MPA (Multi Page Application)
- SPA (Single Page Application)

<br/>
<br/>
## 6. JWT 토큰 탈취 해결 방법

### JWT 탈취 방법

**JWT:** 애플리케이션 간의 정보 교환에 사용되는, JSON 형식의 자체 포함형 토큰
- 클라이언트 측에 저장, 요청에 포함되어 서버에 전달 → 인증과 인가 처리

**서버→클라이언트 전송 과정**
- 네트워크 공격
    - MITM(Man-In-The-Middle, 중간자 공격): 네트워크에서 JWT를 가로챈다.
    - 패킷 스니핑: HTTP 요청을 감청한다.

**클라이언트→서버 요청 과정**
- 네트워크 공격
- XSS(Cross-Site Scripting): 공격자가 웹 사이트에 악성 스크립트 삽입 → 브라우저의 로컬/세션 저장소에 저장된 JWT 탈취
- CSRF(Cross-Site Request Forgery): 공격자가 서버인 척 공격자의 사이트에 요청을 보내도록 유도 → 쿠키에 저장된 JWT 자동 포함

⇒ 토큰을 이용해 인증/인가된 사용자를 가장할 수 있다.
- HTTP의 stateless 속성으로 인해, JWT는 토큰이 탈취되어도 서버에서 유효성을 제어할 수 없다.

<br/>

#### 해결 방법
1. **토큰 저장 위치 보안**
    - HttpOnly 쿠키 → XSS 공격 방지
    - Secure 플래그 활성화 → HTTPS 통신만 허용
    - 로컬 저장소나 세션 저장소 사용 지양
2. **토큰 수명 관리**
    - Access Token의 유효기간을 짧게 설정
    - Refresh Token을 사용하여 보안성, 사용자 경험 밸런스 유지
    - 토큰 무효화(Blacklisting) 매커니즘 구현
3. **Payload 보안**
    - 중요 정보 포함 X, 최소한의 정보만 포함
4. 모니터링 및 로깅
    - 토큰 사용 패턴을 모니터링하고 관련 작업을 로깅하여 의심스러운 활동 감지 시 즉각 대응
5. 추가 인증 계층
    - 중요 작업 수행 시 재인증 요구
    - 2FA(2-Factor Authentication) 구현


<br/>
<br/>

## 오늘의 도전 과제와 해결 방법
- **딥다이브 정리:** 여러 주제에 대해 딥다이브를 진행하고 팀원들과 공유하였다.
- **3주차 과제 시작:** 구현해야 하는 페이지들을 노션에 정리해보다 구현 계획을 세운다.

<br/>
<br/>

## 오늘의 회고
- CS보단 쉬운 것 같다. 실제로 구현하라고 하면 자신 없기는 하지만 원리는 이해했다.
- 웹은 생각보다 계층이 많다. 레이어가 겹겹이 쌓여 있는 이미지다. FE 프로젝트 할 때 CSS를 적용하기 위해 컴포넌트들을 촘촘히 박스로 묶을 때도 느끼긴 했다.

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->