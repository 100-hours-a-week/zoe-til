# TIL Template
날짜: 2025-02-07

<br/>

## 스크럼
**학습 목표:**
````
[1] 딥다이브
[2] 2주차 과제 진행
````
<br/>
<br/>

## 새로 배운 내용
````
- 추상 클래스와 인터페이스
- Java 직렬화, 역직렬화
- Java에서 null의 주의점과 사용 방법
- 멀티 스레드
- Java의 동시성 프로그래밍에서 synchronized와 volatile의 차이
- Java 애플리케이션에서 스레드 안전
````

<br/>

### 추상 클래스와 인터페이스
#### 추상 클래스와 실체 클래스
- **추상 클래스:** 실체 클래스들의 공통적인 특성을 추출하여 선언한 클래스, 객체 생성 X
- **실체 클래스:** 객체를 직접 생성할 수 있는, 추상 클래스를 상속한 자식 클래스

#### 사용 이유
- 코드의 재사용
- 공통적인 기능 미리 정의 / 일부 기능 강제

#### 문법
```java
// 추상 클래스
public abstract class 추상클래스명 {
	// 필드, 생성자, 메소드
	
	public abstract void 추상메소드명();
}

// 실체 클래스
public class 실체클래스명 extends 추상클래스명 {
	// 생성자, ...
	
	@Override
	public void 추상메소드명() {
	
	};
}
```
<br/>

#### 인터페이스
다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스들 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스

#### 사용 이유
- 다중 상속(다중 구현): 하나의 클래스가 여러 개의 상위 클래스를 상속
- 구현 객체 간의 계약(행동 규약) 정의

#### 문법
```java
// 인터페이스
public interface 인터페이스명 {
	// 상수: 인터페이스에서 값을 고정 -> 참조만 가능
	(public static final) 타입 상수명 = 값;
	
	// 추상 메소드: 자식 클래스에서 반드시 오버라이딩하여 구현
	(public abstract) 타입 추상메소드명();
	
	// 디폴트 메소드: 자식 클래스에서 선택적으로 오버라이딩하여 구현
	public default 타입 디폴트메소드명() {
	
	};
	
	// 정적 메소드: 인터페이스에서 고정
	public static 타입 정적메소드명() {
	
	};
}

public class 클래스명 implements 인터페이스 {
	@Override
	추상 메소드 / 디폴트 메소드
	
	메소드() {};
}
```

<br/>
<br/>

### Java 직렬화, 역직렬화
**직렬화 (Serialization):** 자바의 객체나 데이터를 다른 컴퓨터의 Java 시스템에서도 사용할 수 있도록 바이트 스트림 형태의 영연속적인 데이터로 변환하는 포맷 변환 기술
- JVM 메모리의 객체 데이터 → 직렬화 → 외부 저장소에 저장

**역직렬화 (Deserialization):** 바이트 스트림 형태의 데이터를 자바의 객체나 데이터로 변환하는 포맷 변환 기술
- 외부 저장소의 바이트 스트림 데이터 → 역직렬화 → JVM 메모리에 적재

#### 사용처
휘발성이 있는 캐싱 데이터를 영구 저장할 때 사용

- **서블릿 세션(Servlet Session):** 세션 데이터를 저장하거나 공유할 때
- **캐시(Cache):** DB에서 조회한 객체 데이터가 다른 모듈에서도 필요할 때
    - 최근엔 캐시 DB(Redis, Memcached)를 사용한다.
- **자바 RMI(Remote Method Invocation):** 원격 시스템 간의 메시지 교환할 때
    - 최근에는 소켓을 사용한다.

#### 장점
1. 자바 고유 기술 → 자바 시스템에서의 개발에 최적화
2. 자바의 광활한 참조 타입(클래스, 인터페이스 등)에 대해 파싱 없이 전송 가능
3. (직렬화된 외부 파일만 있으면) 생성자 없이 바로 객체 정보를 가진 객체를 사용 가능

#### 단점
1. 용량이 크다. (JSON의 2배 이상)
2. 장기 저장 정보는 직렬화를 지양해야 한다.
3. 직렬화: 모든 멤버 변수가 외부에 노출되어 클래스의 캡슐화가 깨진다.
4. 역직렬화: 버그와 보안에 취약하다.
5. 출시 후 직렬화 형태의 수정이 어렵다. → 유지보수성 X
6. 새로운 버전을 출시할 때 테스트 요소가 많아진다.

<br/>
<br/>

### Java에서 null의 주의점과 사용 방법
#### null
참조형 변수의 원시값, 아무것도 참조하고 있지 않다.

#### `NullPointerException`

컴파일 타임에서 확인되지 않고 런타임에 발생

1. null을 참조하는 객체의 메소드 호출하는 경우
2. 원시형 변수에 null을 할당하는 경우
3. 관계 연산자(>, >=, <, <=)에 null 사용하는 경우
    - ==, != 사용 가능

#### NPE 가드 방법
1. 단정문(assert): 코드가 올바르게 동작하는지 확인하는 키워드
    - 자바 실행시 -ea/-enableassertions 옵션으로 활성화
    - AssertionError: 복구할 수 없는 상태
    ```java
    assert (조건) (: "에러 메시지");
    // 조건: false일 경우 AssertionError
    // 에러 메시지: AssertionError의 상세 정보 생성식
    ```
2. java.util.**Objects**
    - null 여부 체크 메소드: `isNull()`, `nonNull()` 등
    - null일 경우 기본값을 제공하는 메소드: `requireNullElse()`, `requireNonNullElseGet()`
3. java.util.**Optional:** null이 될 수도 있는 값을 감싸는 래퍼 클래스
    - Optional의 변수와 반환값에 null 사용 X
    - 필드, 메소드 매개변수, 집합 자료형에 Optional 사용 X
    - 반환값으로만 사용
4. 어노테이션: `@NonNull`(기본), `@Nullable`(예외적), `@PolyNull`

#### null 사용시 주의점
1. API에 null을 최대한 쓰지 말아라
2. 계약에 의한 설계: 사전조건과 사후조건을 확인하라
3. null 범위를 지역(클래스, 메소드)에 제한하라
4. 초기화를 명확히 하라

<br/>
<br/>

### 멀티 스레드
하드웨어 자원과 상관없이 OS 계층에서  가상 리소스로 동작 → 멀티 스레드 생성 가능

#### 장점
1. 응답성: 다른 스레드가 중단되거나 시간이 많이 걸려도 프로그램의 수행이 가능하다.
2. 경제성: 멀티 프로세스를 활용할 때보다 오버헤드를 줄일 수 있다.
3. 동시성/병렬성을 만족하는 실행 흐름: 다중 CPU 구조에서 각 프로세서에서 각각의 스레드들이 병렬로 수행한다.

#### 단점
1. 싱글 코어 멀티 스레딩: 스레드 생성 시간이 오버헤드로 작용 → 단일 스레드보다 느리다.
2. 스레드마다 독립적인 PC와 스택 영역 → 메모리와 시스템 자원을 많이 소비하게 된다.
3. 경쟁 상태: 여러 스레드가 동일한 자원에 동시 접근 → 데이터의 일관성이 깨질 수 있다. ⇒ 동기화 필요
    - lock 매커니즘을 이용하는 동기화 객체: mutex, Semapore, Event 등

#### 생명주기
1. New: 스레드가 생성되었으나 아직 시작되지 않은 상태
2. Runnable: 실행 중 또는 실행될 준비가 되어 스케줄러 큐에 대기 중
3. 일시중지
    1. Blocked: 스레드가 동기화 lock을 기다리는 상태
    2. Waiting: 스레드가 무기한으로 다른 스레드의 작업을 기다리는 상태
    3. Timed Waiting: 스레드가 일정 시간 동안 다른 스레드의 작업을 기다리는 상태
4. Terminated: 스레드의 실행이 완료된 상태

<br/>

#### Deadlock
둘 이상의 스레드가 서로의 작업이 끝나기만을 기다리며 작업을 더 이상 진행하지 못하는 상태

**발생조건:** 전부 충족해야 발생한다.

1. **상호 배제(Mutual Exclusion):** 자원은 배타적으로 한 번에 한 스레드만 사용할 수 있고, 다른 스레드가 사용 중일 경우 대기한다.
2. **점유와 대기(Hold and Wait):** 스레드가 최소 하나의 자원을 사용 중인 상태에서 다른 스레드에 의해 점유된 다른 자원을 할당 받기를 요구한다.
3. **비선점(No Preemption):** 자신의 작업 수행이 끝날 때까지 자원을 반환하지 않는다.
4. **원형 대기(Circular Wait):** 프로세스들이 순환 형태로 서로의 자원을 기다린다.


**해결방법**

1. 예방: 교착 상태 유발 조건을 무력화한다.
2. 회피: 교착 상태가 발생하지 않는 수준으로 자원을 할당한다.
3. 검출: 자원 할당 그래프를 사용하여 교착 상태를 검출한다.

<br/>

#### **스레드 풀(Thread Pool)**

요청당 스레드(thread-per-request): 매 요청마다 스레드 생성

1. 스레드 생성과 종료에 많은 시간 허비
2. 스레드의 독자적인 스택 영역 할당에 자원을 많이 소비
3. 스레드 수가 많을수록 Context Switching 오버헤드 증가

**⇒** 스레드를 미리 일정 개수 생성하여 재사용하는 방식

**동작원리**

1. 스레드를 미리 생성해 둔다.
2. 자료구조의 대기열(큐)를 이용하여 작업을 스레드에게 전달한다.
3. 생산자-소비자 패턴(생산자: 작업 전달 애플리케이션, 소비자: 작업 처리 스레드)
    1. 스레드 풀의 스레드: 작업 대기열에서 blocking 상태로 대기
    2. 애플리케이션 → 스레드: 작업 처리 요청 → 작업 대기열에 작업 할당
    3. enqueue된 스레드: 작업 시작 ~ 완료 → 콜백 형태로 애플리케이션에게 결과 전달


<br/>
<br/>

### Java의 동시성 프로그래밍에서 synchronized와 volatile의 차이
#### **synchronized**

스레드가 임계 영역에 들어가거나 나올 때 캐시-메모리 간 동기화 → 함수의 원자성을 보장
- lock 방식을 사용하기 때문에 성능이 떨어진다.
```java
// 메소드에 사용
public synchronized void function () {
	// 임계 영역
}

// 코드 블록에 사용
void function() {
	synchronized(this) {
		// 임계 영역
	}
}
```

<br/>

### **volatile**

스레드가 캐시 대신 메모리에서 직접 읽는다. → 변수의 가시성 보장

- 접근 시간이 오래 걸려 성능이 떨어진다.
- 원자성을 보장하지 못한다. → `synchronized` 키워드를 사용

```java
public class SharedObject {
	public volatile int counter = 0;
}
```

**사용처:** 하드웨어와의 직접적 상호작용이 필요할 때 컴파일러의 최적화로 인한 문제 발생을 방지

1. 인터럽트 서비스 루틴: 사전에 정의해 놓은, 하드웨어 인터럽트(입력) 발생시 실행 내용
2. 메모리 맵 입출력: 특정 메모리 주소를 통해 하드웨어 장치와 통신
3. 신호 처리: OS의 신호 처리기와 메인 프로그램 간 사용되는 변수


<br/>
<br/>

### Java 애플리케이션에서 스레드 안전
#### 스레드 안전 (Thread-safety)

멀티 스레드 환경에서 특정 변수, 함수, 객체 등의 자원에 여러 스레드가 동시에 접근해도 프로그램 실행에 문제가 발생하지 않음을 보장하는 상태

→ 스레드가 경쟁 상태에 놓여도 연산 결과의 정합성이 보장되도록 메모리 가시성이 확보된 상태

#### 판단 방법

1. 여러 스레드에서 동시에 접근할 수 있는 공유 자원을 연산 수행에 사용하는가?
2. 데이터에 핸들과 포인터를 통한 간접 접근이 가능한가?
3. 부수 효과를 가져오는 코드가 있는가?

#### 스레드 안전 보장 전략

1. **상호 배제(Mutual Exclusion), 동기화**
    - 한 번에 하나의 스레드만 특정 코드 영역에 접근 가능하다.
    - Lock, Semaphore, Mutex 활용
2. **재진입성(Re-entrancy)**
    - 어떤 함수에 여러 스레드가 동시에 접근해도 항상 동일한 실행 결과를 보장한다.
    - 정적, 전역 변수 대신 지역 변수에 상태 정보를 저장
3. **불변성(Immutability)**
    - 생성된 데이터가 변경되지 않도록 공유 데이터에 대한 동시 접근 문제를 해결한다.
    - `final` 키워드
4. **스레드 로컬 저장소(Thread-Local Storage, TLS)**
    - 각 스레드가 자신만의 데이터 복사본 보유 → 공유 데이터 문제 회피한다.
    - `ThreadLocal` 변수 → 각 스레드에 고유한 데이터 객체 제공
5. **원자적 연산(Atomic Operations)**
    - 데이터에 대한 연산을 단일 단위로 분할 → 동시성 문제 없이 실행 가능하게 한다.
    - `Atomic` 클래스, CAP 알고리즘 연산
6. **고립(Isolation)**
    - 작업을 독립적으로 만들어 서로 영향을 주지 않도록 한다.
    - 데이터베이스의 트랜잭션 관리, 메시지 큐를 통한 작업 분리

<br/>
<br/>

## 오늘의 회고
- 딥다이브는 오래 걸리고 힘들다. 팀과의 공유 시간이 없었다면 더 힘들었을 것 같다.
- 오늘 딥다이브는 '이걸 굳이 알아야 하나...?' 싶은 질문도 있었던 것 같다. 예를 들면 직렬성... 단점이 너무 많아서 실무에서 쓰이긴 하나? 싶다.
- 2주차 과제를 슬슬 정말 시작하자! 힘내야지, 뭐. 어쩌겠나.

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->