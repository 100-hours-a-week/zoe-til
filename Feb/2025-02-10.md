# TIL Template
날짜: 2025-02-10

<br/>

## 스크럼
**학습 목표:**
- 강의 내용 정리
- 2주차 과제 마무리


<br/>
<br/>

## 새로 배운 내용
````
- 공유자원
- 임계영역
- 동기화
- lock
````

<br/>

###
공유 자원: 여러 작업이 동시에 접근하거나 사용하는 자원	

임계 영역: 공유 자원에서 문제가 생기지 않게 독점을 보장해줘야 하는 영역	

동기화: 여러 작업이 공유 자원에 동시에 접근할 때 발생할 수 있는 문제들을 방지하여 데이터 무결성과 작업의 일관성을 보장하는 기술	

락: 다른 작업이 어떤 작업이 점유하고 있는 자원에 접근하지 못하도록 하는 기법	

원자성: 성공적으로 완료되거나 아예 실행하지 않은 상태로 롤백하는 성질. 0이거나 1

상호배제(Mutual Exclusion): 임계 영역에 반드시 하나의 작업만 진입하도록 제한	

진행(Progress): 대기 중이던 작업들 중 하나가 신호를 받고 실행	

유한한 대기(Bounded Wating): 대기 중인 작업의 영구적 차단을 방지, 언젠가 실행될 것임을 보장	

데드락: 락의 해제에 실패하거나 락을 잘못된 순서로 걸어 발생하는 무한 대기 문제

Race Condition: 공용 자원에 두 작업이 동시에 접근하여 발생하는 경쟁 상태	. 데이터 무결성 문제 발생

기아 현상: 우선순위가 낮은 작업이 계속해서 자원을 할당받지 못하는 상태	

Lock-Free: 공유 자원에 접근하는 여러 스레드들 중 최소한 하나의 작업의 고립된 실행을 보장하고 나머지는 롤백
- 교착 상태가 없다.
- 우선순위 역전이 없다.
- 모든 작업 완료까지 소요되는 시간이 보장되지 않는다.
- 일부 작업이 더 많은 자원을 사용하여 다른 작업의 진행을 방해 가능

Wait-Free: 어떤 작업도 wati하지 않고 항상 모두 실행 중
- 무한 대기가 없다.
- 유한한 시간 내에 작업 완료 보장
- 구현이 복잡하다.
- 성능 상 오버헤드가 발생할 수 있다.

<br/>

스핀락: 대기 상태의 작업이 공유 자원의 락 상태를 반복적으로 확인하는 방식. 반복 확인에 CPU를 사용하므로 락 해제 시간이 짧아야 효율적이다.

낙관적 락: 락을 사용하지 않고, 충돌이 드물다는 가정 하에 공유 자원을 사용하는 방식. 충돌이 발생할 경우 롤백한다.

뮤텍스: 상호배제를 위해 한번에 한 작업만 공유 자원을 사용할 수 있도록 락을 거는 방식, 락의 소유권과 해제권을 작업에 부여한다. 뮤텍스 대기큐를 통해 대기 작업 목록과 뮤텍스 락의 소유권을 관리한다.

조건 변수(Condition Variable): 특정 조건을 충족해야 대기 상태에서 깨어나 자원을 할당받을 수 있다. 일반적으로 뮤텍스와 함께 사용한다.

Read-Write Lock: Read Lock, Write Lock을 따로 관리하여 읽기 요청은 동시성을 지원하고 쓰기 요청은 독점적 사용을 지원한다. Write 작업이 다수의 Read 작업에 의해 기아 상태가 될 수 있다.

세마포어: 한번에 제한된 개수의 작업만 공유 자원을 사용할 수 있도록 카운터를 사용하여 관리한다.	 wait가 호출될 때마다 카운터 값을 1씩 감소하고, 카운터의 값이 0 이하가 되면 락을 건다.

분산 락: 서버가 여러 대인 상황에서 전체 서버에 동일한 데이터에 대한 동기화를 보장
- 여러 서버로 API가 분산 호출될 때, 서버들 간 동기화 처리를 통해 공통된 락을 적용
- DB 등 공통된 데이터 저장소를 이용해 자원 사용 여부를 확인

<br/>
<br/>

#### 공유 자원이란 무엇이며, 왜 시스템에서 공유 자원을 사용해야 할까요? 실생활 또는 개발 경험에 빗대어 설명해주세요.
공통적으로 사용되는 자원을 각 작업이 독립적으로 저장하고 사용한다면 컴퓨터의 메모리 부하가 올라가고 프로그램 성능이 떨어질 것이다. 또한 각 작업이 서로 데이터를 공유해야 할 때 오버헤드가 추가로 발생할 수 있다.	

<br/>

#### 임계 영역의 정의와 중요성을 설명하고, 임계 영역을 보호하지 않았을 때 발생할 수 있는 가장 심각한 문제는 무엇이라고 생각하십니까?
공용 자원이 사용되는 임계 영역을 보호하지 않아 두 개 이상의 작업이 동시에 임계 영역에 접근할 경우, 데이터 무결성 문제가 생기면서 각 작업의 결과가 작업 순서에 따라 일정하게 보장되지 않게 되며 프로그램에 대한 사용자의 경험과 신뢰성이 떨어진다.	

<br/>

#### 동기화 메커니즘이 필요한 이유를 데이터 무결성과 관련지어 설명해주세요. 동기화가 없다면 발생할 수 있는 문제 3가지 이상을 예시와 함께 설명해주세요.	
위의 이유로 동기화를 통해 상호 배제적 프로그래밍을 진행해야 한다. 즉, 데이터 무결성을 보장하기 위해 공용 자원을 한번에 한 작업만 점유할 수 있게 해야 한다.	 만약 동기화가 없을 경우
- 데이터 무결성 문제
- 프로그램 실행에 심각한 오류 발생
- 결과값의 일관성을 보장 불가

<br/>

#### 락의 기본적인 개념과 동작 방식을 설명해주세요. 락이 데이터 무결성을 어떻게 보장하는지 원자성 개념과 함께 설명해주시면 좋겠습니다.
락은 한 작업이 임계 영역을 점유하고 있을 경우 다른 작업의 접근을 막는 기술로, 이때 다른 작업은 대기 큐에서 대기 상태에 있다가 실행 중이던 작업이 완료되었을 경우 신호를 받아 깨어난다.

락은 각 작업이 충돌을 일으킬 상황에 있을 땐 대기큐로 보내고, 안전하게 작업을 할 수 있는 상황에서만 독점적으로 실행시켜 작업이 안전하게 실행될 수 있음을, 즉 작업의 원자성을 보장한다.

<br/>

#### 뮤텍스와 세마포어의 차이점을 설명하고, 각각 어떤 상황에서 사용하는 것이 적절한지 예시를 들어 설명해주세요.
뮤텍스는 공유 자원을 하나의 자원만 점유할 경우, 세마포어는 공유 자원을 특정 개수의 자원이 점유할 경우에 사용한다.	

<br/>

#### 조건 변수(Condition Variable)는 왜 뮤텍스와 함께 사용해야 할까요? 조건 변수의 역할과 뮤텍스와의 협력 관계를 설명해주세요.
조건 변수는 공유자원의 상태, 즉 논리적 조건이 충족될 때까지 대기 큐에 넣어두는 방식이므로, 뮤텍스 대기 큐가 기존 작업이 완료되기만 하면 논리적 조건과 상관없이 작업을 꺼내 생기는 문제에 대해 안전 장치 역할을 수행할 수 있다.
1. 스레드가 조건을 충족할 때까지 조건 변수 대기 큐에서 대기한다.
2. 조건을 충족한 스레드는 차례가 될 때까지 뮤텍스 대기 큐에서 대기한다.

<br/>

#### 뮤텍스는 데드락 발생 가능성이 있습니다. 데드락의 발생 조건 4가지를 설명하고, 데드락을 예방하기 위한 방법 3가지 이상을 제시해주세요.
**발생 조건(모두 충족시)**
1. 상호배제
2. 점유 대기
3. 비선점
4. 순환 대기

⇒ 작업이 한번에 하나의 자원만 점유 가능할 때, b를 점유한 A는 a를 대기하고, a를 점유한 B는 b를 대기하는 상황

**해결**
1. 예방: 발생 조건 중 하나라도 충족되지 못하게 한다.
2. 회피: 데드락이 발생하지 않을 정도로만 자원을 할당한다.
3. 검출: 자원 할당 그래프를 사용하여 데드락을 검출한다.

<br/>

#### 낙관적 락(Optimistic Lock)은 충돌이 적을 것이라고 가정하고 작동합니다. 만약 충돌이 빈번하게 발생한다면 낙관적 락의 성능은 어떻게 될까요? 낙관적 락의 장점과 단점을 비교 설명해주세요.
낙관적 락은 충돌이 발생할 때마다 작업을 롤백하므로 롤백 비용이 발생하고 성능이 저하된다.
- 장점: 락을 사용하지 않으므로 오버헤드가 낮으므로 경쟁 상태가 적다면 효율적이다.
- 단점: 충돌이 많이 발생한다면 롤백 비용이 많이 발생하고 성능이 저하된다.

<br/>

#### 데이터베이스 커넥션 풀 또는 스레드 풀을 설계할 때 세마포어(Semaphore)를 어떻게 활용할 수 있을까요? 세마포어의 장점을 활용하여 자원 관리 효율성을 높이는 방안을 설명해주세요.
커넥션 풀 또는 스레드 풀은 사용하는 자원의 개수를 제한한다. 여기에 세마포어, 즉 임계 구역에 진입하는 작업의 개수를 특정 개수로 제한하는 기술을 사용할 수 있을 것이다.

이를 위해 커넥션 풀 또는 스레드 풀은 원자적 변수(공통 변수)를 하나 설정하고, 보유한 자원이 사용될 때마다 카운트 값을 1씩 깎다가 0이 되면 락을 거는 알고리즘 방식을 적용할 수 있다.
이를 통해 메모리의 낭비를 줄이면서 작업의 원자성을 보장하고 안전성을 높일 수 있다.

<br/>

#### JavaScript 프레임워크에서 비동기 작업을 처리하고 상태 관리를 할 때 동시성 문제를 어떻게 고려해야 할까요?
비동기는 작업이 순차적으로 진행되지 않고 독립적으로 처리되는 방법이고, 동시성은 작업들이 동시에 처리되는 것처럼 보이도록 빠르게 문맥 교환을 하는 속성이다.

따라서 비동기 작업을 처리하면서 동시성 문제를 고려한다면, 작업들은 빠르게 문맥 교환을 하면서 동시에 실행되는 것처럼 보이는 동시에 문맥 교환을 하는 작업들의 순서는 독립적일 것이다. 


<br/>
<br/>

## 오늘의 도전 과제와 해결 방법
**강의 내용 정리:** 강의를 수강하고 내용을 정리했다.
**2주차 과제 마무리:** 과제를 구현하고 커밋한 뒤, 회고와 함께 제출한다.

<br/>
<br/>

## 오늘의 회고
- 

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->