# TIL Template
날짜: 2025-02-17

<br/>

## 스크럼
**학습 목표:**
- 강의 내용 정리
- 3주차 과제 시작


<br/>
<br/>

## 새로 배운 내용
````
- Cookie
- Storage
- Session
````

<br/>

### 개념 키워드 정리
| **개념** | **설명** | **비고** |
| --- | --- | --- |
| 쿠키 | 인터넷 사용자가 웹 사이트를 방문할 경우, 서버를 통해 로컬에 저장되는 작은 기록 정보 파일 |  |
| 퍼스트파티 쿠키 | 사용자가 접속한 웹 사이트에서 직접 설정하는 쿠키 |  |
| 서드파티 쿠키 | 사용자가 방문한 웹 사이트의 도메인과 다른 도메인에서 설정하는 쿠키 | 퍼스트파티보다 보안 위험성이 높다. |
| 쿠키 보안 속성 | HttpOnly: JS를 통한 쿠키의 접근을 차단한다.<br/>Secure: HTTPS를 통한 쿠키의 접근만 허용한다.<br/>SameSite: 퍼스트파티로 제한한다. | SameSite의 옵션 목록<br/>- Strict: 퍼스트파티만 허용<br/>- Lax: 완전한 GET 요청의 서드파티까지 허용<br/>- None: HTTPS에서의 모든 서드파티를 허용 |
| 세션 | 컴퓨터 프로세스 간 연결이 지속되는 동안 유지되는 상태 정보
웹 브라우저로부터 세션 ID를 받아 서버 측 저장소에서 조회한다. | 쿠키와 함께 사용된다. |
| 세션 ID와 쿠키의 관계 | 요청한 사용자의 정보를 구별할 수 있는 세션 ID를 쿠키에 저장한다.<br/>쿠키는 요청 시 세션에 세션 ID를 넘겨 스토리지에서 조회할 수 있게 한다. |  |
| 로컬 스토리지 | 데이터를 웹 브라우저에 영구히 저장하는 장치 |  |
| 세션 스토리지 | 웹 브라우저 창이 열려 있는 동안(세션 종료 전까지) 데이터를 웹 브라우저에 일시적으로 저장하는 장치 |  |

<br/>

### HTTP가 본질적으로 Stateless하다는 의미와, 웹 애플리케이션에서 상태 유지를 위해 사용하는 기법

HTTP는 기본적으로 사용자의 상태를 저장하지 않는다. 즉, 매 요청을 새로운 요청으로 인식하고 응답한다. 이 특성은 서버의 오버헤드를 줄여주지만 로그인 등 사용자를 인식해야 하는 일이 생길 때 문제가 된다.

따라서 웹 애플리케이션에서 상태를 유지하기 위해 쿠키와 세션을 사용한다.

쿠키는 사용자의 컴퓨터에 상태 정보를 저장되는 텍스트 데이터고, 매 요청마다 상태 정보를 함께 전달하여 웹 사이트가 사용자를 구별할 수 있도록 한다. 하지만 이 경우 XSS 공격 등 요청을 중간에 탈취당하는 등 보안 위험도가 높다.

따라서 웹 애플리케이션은 쿠키와 세션을 동시에 사용한다. 세션은 서버의 세션 저장소에 상태 정보를 저장하는 기술이다. 쿠키는 세션 ID만 저장하여 세션이 민감한 정보를 관리하여 보안을 높인다.

결과적으로 웹 브라우저가 요청과 함께 쿠키의 세션 ID를 서버에 전달하면 서버는 세션 ID를 통해 스토리지를 조회하여 상태 정보를 인식한다. 이와 같은 방식으로 웹 애플리케이션은 Stateless한 HTTP에서 로그인 등 상태 유지 기법을 사용할 수 있다.

<br/>

### 매 요청 시 쿠키가 전송됨에 따른 네트워크 오버헤드 문제와 이를 완화할 수 있는 방법

쿠키는 매 요청마다 HTTP 헤더에 삽입되어 서버로 전달되기 때문에 네트워크 오버헤드를 유발한다. 따라서 쿠키의 크기가 커지면 오버헤드가 커지면서 네트워크 지연이 발생한다.

이때 웹 스토리지를 사용하면 쿠키의 크기를 줄이고 네트워크 오버헤드를 줄일 수 있다. 자주 변경되지 않는 데이터를 웹 스토리지에 저장하거나 필수적인 정보만 쿠키에 유지한다. 결론적으로 쿠키의 데이터를 웹 스토리지에 저장해두고 필요한 만큼의 데이터만 요청에 포함시킬 수 있다.

<br/>

### 쿠키의 만료 시간을 설정하는 Expires와 Max-Age 옵션의 차이점

`MaxAge`는 쿠키가 유지되는 시간(초)를 정의한다. 이 값에 현재 시간이 더해져서 쿠키의 만료 시간이 상대적으로 계산된다. (3600 = 1시간)

```jsx
document.cookie = "user=xyz; max-age=3600";
```

`Expires`는 쿠키가 만료되는 날짜와 시간을 절대적인 HTTP Date 형식의 문자열로 설정한다.

```jsx
let date = new Date(Date.now() + 86400e3);
date = date.toUTCString();
document.cookie = "user=xyz; expires=" + date;
```

만약 두 옵션 중 하나라도 설정하지 않는다면 쿠키는 브라우저가 종료될 때까지 유지되며, 이를 **Session Cookie**라고 한다.

만약 두 옵션이 모두 설정되어 있다면 IE 6-8은 Expires를, 나머지 최신 브라우저들은 Max-Aage를 우선으로 인식한다.

Expires는 절대적인 시간을 사용하기 때문에 서버와 클라이언트의 시간대가 다를 경우 시간대(timezoe) 이슈가 발생할 수 있다. 결론적으로 문법이 간결하고 시간대 이슈가 없어 쿠키 만료 시간을 안정적으로 설정할 수 있으며 서버와 클라이언트 간 시간 불일치 문제를 방지하는 Max-Age 사용이 권장된다.

<br/>

### CSRF 공격이란 무엇이며, SameSite 속성을 통해 이를 어떻게 예방할 수 있는지 설명해 주세요.

CSRF(Cross-Site Request Forgery)은 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하게 만드는 공격 기법이다. 공격자가 전송한 CSRF 스크립트가 포함된 게시물을 관리자가 열람하게 되면, 관리자의 권한으로 스크립트 요청이 발생하고 실행된다.

이를 예방하기 위해 쿠키는 SameSite 옵션을 사용한다. SameSite는 요청에 대한 쿠키의 전송 범위를 제한하는 옵션으로, SameSite의 옵션에 따라 그 범위가 달라진다. 옵션을 명시하지 않을 경우 Lax가 기본값이다.

Strict는 퍼스트파티일 경우, 즉 사용자와 방문 중인 웹 사이트의 도메인과 같은 도메인에 보내는 요청일 경우에만 전송을 허용한다.

Lax는 퍼스트파티거나 완전한 GET 요청의 서드파티, 즉 요청이 서버를 변경하지 않을 경우에만 전송을 허용한다.

None은 Secure 옵션을 설정하였을 경우, 모든 서드파티의 전송을 허용한다.

<br/>

### XSS 공격의 동작 원리와, HttpOnly 속성이 쿠키를 보호하는 방식에 대해 설명해 주세요.

XSS(Cross Site Scripting)은 웹 사이트에 스크립트를 삽입하여 의도치 않은 동작을 일으키는 공격이다. 다음과 같은 종류로 나뉜다.

**Stored XSS**
    1. 공격자가 악성 스크립트를 서버에 저장한다.
    2. 서버가 악성 스크립트를 데이터베이스에 저장한다.
    3. 사용자가 URL을 열람하면 악성 스크립트가 포함된 응답이 전송되어 악성 스크립트가 실행된다.

**Reflected XSS**

1. 공격자가 악성 스크립트가 포함된 URL을 만들고 사용자가 URL을 열람한다.
2. 서버가 URL의 검색 파라미터를 그대로 응답 페이지에 포함하여 반환한다.
3. 악성 스크립트가 실행된다.

**DOM based XSS**

1. 공격자가 DOM을 조작하는 페이지의 취약점을 발견하여 악성 스크립트가 포함된 URL을 만든다.
2. 사용자가 URL을 열람하면 브라우저의 JS가 서버를 거치지 않고 URL의 해시값을 DOM에 직접 삽입한다.
3. 클라이언트에서 악성 스크립트가 실행된다.

이 공격에 대응하여 쿠키를 탈취당하지 않기 위해 쿠키는 `HttpOnly` 옵션을 사용한다. 이를 통해 클라이언트 측에서 HTTP 통신 외에는 쿠키에 접근할 수 없도록 만든다. 즉, `document.cookie`를 통한 JS 접근을 차단한다.

이때 HttpOnly는 XSS 공격 전체를 차단하는 것이 아니라 쿠키의 탈취만 방지한다.

<br/>
<br/>

## 오늘의 도전 과제와 해결 방법
**강의 내용 정리:** 강의를 수강하고 내용을 정리했다.

<br/>
<br/>

## 오늘의 회고
- 조원들과 개념 정리를 하는 과정에서 JWT를 사용해서 쿠키의 네트워크 오버헤드를 줄일 수 있는가 깊게 논의하게 되었다. 결과적으로 JWT에 대해서도 딥다이브할 수 있는 시간이었다.
- 곧이 곧대로 듣는 것이 제일 편한 학습 방법이긴 하지만 이게 옳은 정보인가 스스로 점검하는 과정에서 더 깊게 이해할 수 있는 것 같다. 그리고 이 방법으로 생성형 AI를 더 제대로 사용할 수 있는 듯...

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->