# TIL Template
날짜: 2025-02-05

<br/>

## 스크럼
**학습 목표:** KTB 강의 수강 후 개념 정리

<br/>
<br/>

## 새로 배운 내용
````
- 동기와 비동기
- 블로킹과 논블로킹
````

<br/>

### 동기와 비동기
#### 동기
- 작업의 실행이 이전 작업의 결과 처리에 의존한다.
- 작업 실행 → 결과 처리 → 작업 실행 → 결과 처리 → …

#### 비동기
- 작업의 실행이 이전 작업의 결과 처리에 의존하지 않는다.
- 작업1 실행 → 작업2 실행 → 작업3 실행
→ 작업2의 결과 처리 요청→ 작업3 실행 완료 → 작업2 결과 처리
→ 작업3의 결과 처리 요청 → 작업1의 결과 처리 요청 → 작업3 결과 처리 → 작업1 결과 처리

#### 차이점
- 동기에서는 파일 읽기 함수 실행 후 완료까지 기다린 다음에 다음 명령어를 실행한다. (순서 보장 O)
- 비동기에서는 파일 읽기 함수 실행 후 다음 명령어를 함께 실행하고 먼저 완료된 작업부터 결과 처리한다. (순서 보장 X)

<br/>
<br/>

### 블로킹과 논블로킹
#### 블로킹
- 제어권 반환이 이전 작업의 결과 처리에 의존한다.
- 이전 작업의 결과 처리 → 제어권 반환 → 다음 작업 실행

#### 논블로킹
- 제어권 반환이 이전 작업의 실행에 의존한다.
- 이전 작업 실행 → 제어권 반환, 작업 수행 → 다음 작업 실행

#### 제어권 관점
- 블로킹은 작업이 결과 처리될 때까지 제어권을 넘겨준다.
- 논블로킹은 작업을 실행만 시키고 제어권을 즉시 반환받는다.

<br/>
<br/>

### 교차 시나리오
#### Sync-Blocking과 Sync-Nonblocking의 차이
- Sync-Blocking은 제어권 전달과 결과 처리가 함께 진행되어 현재 작업이 완료될 때까지 다른 작업을 실행할 수 없지만, Sync-Nonblocking은 현재 작업이 완료되기를 기다리며 다른 작업을 실행할 수 있다.
- 결과 처리는 순차적으로 진행된다.(동기)

<br/>

#### 비동기 I/O와 논블로킹 I/O 개념 차이
- 작업의 ‘실행’이 병렬적으로 진행될 수 있다는 것은 논블로킹 방식이고, 작업의 ‘결과 처리’가 비순차적으로 진행될 수 있다는 것이 비동기의 개념이다.
- 비동기는 각 작업이 병렬적으로 실행되는 방식이고, 논블로킹은 각 작업이 독립적으로 실행되는 방식이다.

<br/>

#### 멀티 스레드 환경에서 블로킹 I/O를 사용할 때 발생하는 Context Switching Overhead를 줄이기 위한 방법
멀티스레드에서 동기화 처리를 하기 위해 `syncronized` 키워드를 사용하는 경우, 블로킹 방식을 사용한다. 이 경우 임계 영역에 lock을 걸어 다른 스레드가 진입하지 못하게 만듦으로써 부하를 주게 된다.
블로킹 대신 `Atomic` 클래스를 통해 논블로킹 방식을 사용하면서 컨텍스트 스위칭 오버헤드를 줄일 수 있다.
- `volatile` 키워드: 변수 가시성 보장 O, 원자성 보장 X
- `Atomic` 클래스: CAS 알고리즘을 통해 기존값==예상값일 때(가시성) 값을 변경(원자성)

<br/>

#### 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능 이점
논블로킹 방식은 제어권 분산을 통해 여러 작업이 독립적이고 병렬적으로 실행함으로써 멀티태스킹 작업을 가능하게 만들어 컴퓨터의 성능을 높인다.

<br/>
<br/>

## 오늘의 회고
- 2주차 과제에 적용해야 하는 중요한 개념이다. 잘할 수 있을지...
- 논블로킹 방식에서 제어권을 다른 작업으로 아예 안 넘겨주고 실행만 시킨다는 설명도 존재한다. 결과적으로 '실행만' 시킨다는 처리 방식은 동일하니 어느 쪽도 상관 없을 것 같긴 하다.

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->