# TIL Template
날짜: 2025-02-24

<br/>

## 스크럼
**학습 목표:**
- 강의 내용 정리
- 3주차 과제 끝내기


<br/>
<br/>

## 새로 배운 내용
````
- 실행 컨텍스트
- 스코프
- this
- 클로저
- 프로토타입
````

<br/>

### 개념 키워드 정리
| **개념** | **설명** |
| --- | --- |
| Exeution Context | 코드가 실행될 때 제공할 환경 정보들을 모아둔 객체 |
| 전역 실행 컨텍스트 / 함수 실행 컨텍스트 | **전역:** 코드가 처음 실행될 때 생성되는 기본 컨텍스트<br/>**함수:** 함수가 호출될 때마다 생성되는 실행 컨텍스트 |
| 콜스택 과정 | 코드 실행 순서를 기억하고 관리하는 데이터 구조, LIFO 방식 |
| 스코프 체인 | 변수를 찾기 위해 내부 스코프에서 외부 스코프로 단계적으로 탐색하는 과정 |
| 변수 호이스팅 / 함수 호이스팅 | • **변수:** 선언만 호이스팅한다.<br/> ◦ `var`: undefined로 초기화 → 실제 코드 도달 시 할당<br/?◦ `let`: 초기화 전까지 TDZ에 존재 → 초기화 코드 도달 시 초기화<br/>◦ `const`: 초기화 전까지 TDZ에 존재 → 선언과 동시에 초기화<br/>• **함수 선언문:** 함수 전체를 호이스팅한다.<br/>• **함수 표현식:** 변수 호이스팅 규칙을 따른다. |
| this | 함수가 호출되는 방식에 따라 this가 가리키는 대상이 결정되는 것 |
| 바인딩 결정 방식 정리 | **기본 바인딩:** 단독 함수로 호출될 때<br/>**명시적 바인딩:** callback일 때 call, apply, bind 메서드로 this를 직접 지정<br/>**암시적 바인딩:** 객체의 메서드로 호출될 때<br/>**new 바인딩:** new 키워드로 함수가 호출될 때 |
| call, apply, bind 메소드 | **apply, call:** `this`로 사용할 객체를 1번째 인자로 전달<br/>**bind:** 1번째 인자값으로 전달된 객체에 `this`를 고정한 새로운 함수를 반환 |
| arrow function과 일반 함수의 this 차이 | arrow function은 자신만의 this를 가지지 않고 외부 스코프의 this를 상속받는다. |
| 클로저 | 함수가 자신이 생성될 때의 환경을 기억하여 접근할 수 있는 기능 |
| 장단점 및 메모리 관리 이슈 | **장점:** 데이터 은닉이 가능<br/>**단점:** 메모리 누수의 위험 |
| 클로저를 활용한 모듈 패턴 | 비공개 변수와 메서드를 구현할 수 있는 디자인 패턴 |
| 프로토타입 | 객체들 간에 공유되는 속성과 메서드를 담고 있는 객체 |
| 프로토타입 체인 | 객체의 속성을 찾을 때 상위 프로토타입으로 순차적으로 검색하는 방식 |
| class와 프로토타입의 차이 | 클래스: `extends`와 `super`를 사용하여 명시적 상속<br/>프로토타입: 프로토타입 체인의 연결을 통해 상속 |



<br/>
<br/>

## 오늘의 도전 과제와 해결 방법
**강의 내용 정리:** 강의를 수강하고 내용을 정리했다.<br/>
**3주차 과제 끝내기:** 반드시...

<br/>
<br/>

## 오늘의 회고
- JS는 밀리더라도 3주차 레이아웃은 끝을 내야 한다... 해커톤에 마음 놓고 참여하려면 진짜진짜로ㅜ

<!-- ### 참고 자료 및 링크
- [링크 제목](URL)
- [링크 제목](URL) -->